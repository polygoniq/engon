# copyright (c) 2018- polygoniq xyz s.r.o.

import bpy
import os
import json
import re
import typing
import collections.abc
import pathlib
import sys
import logging
from . import errors

logger = logging.getLogger(f"polygoniq.{__name__}")

BLENDER_VERSION_RE = re.compile(r"^(\d+)\.(\d+)$")

CONFIG_EXT = ".json"


def get_global_config_dir(addon_name: str, create: bool = False) -> pathlib.Path:
    """Get the global polygoniq config directory for the addon."""
    if sys.platform.startswith("win"):
        directory = pathlib.Path.home() / "AppData" / "Local" / "polygoniq"
    elif sys.platform.startswith("linux"):
        xdg_config_home = os.environ.get("XDG_CONFIG_HOME", None)
        if xdg_config_home is not None:
            directory = pathlib.Path(xdg_config_home) / "polygoniq"
        else:
            directory = pathlib.Path.home() / ".config" / "polygoniq"
    elif sys.platform.startswith("darwin"):
        directory = pathlib.Path.home() / "Library" / "Application Support" / "polygoniq"
    else:
        raise NotImplementedError(f"Platform {sys.platform} not supported")

    directory = directory / addon_name
    if create and not directory.exists():
        directory.mkdir(parents=True)
    return directory


def get_blender_specific_config_dir(addon_name: str, create: bool = False) -> pathlib.Path:
    """Get the blender-specific config directory for the addon."""
    str_path = bpy.utils.user_resource('CONFIG', path=addon_name, create=create)
    return pathlib.Path(str_path)


def get_config_file_name(config_name: str) -> str:
    return f"{config_name}{CONFIG_EXT}"


def save_config(path: pathlib.Path, data: typing.Any, pretty_print: bool = False) -> None:
    with path.open("w", encoding="utf-8") as f:
        json.dump(data, f, indent=4 if pretty_print else None)


def load_config(path: pathlib.Path) -> typing.Any:
    with path.open("r", encoding="utf-8") as f:
        return json.load(f)


def list_versions_with_config(
    addon_name: str, config_name: str, exclude_current: bool = False
) -> collections.abc.Iterator[tuple[str, pathlib.Path]]:
    """Search for the config file in 'config' folder of other Blender versions.

    Returns an iterator of all Blender versions where the config file was found
    in the format `(version, config_file_path)`. This will search only in user/system
    installations of Blender (we can't search portable versions or custom paths).
    """
    # By default, this will be `.../[bB]lender/"version"` on all platforms
    # We need to go up to the `blender` dir and check all versions
    config_path = pathlib.Path(bpy.utils.resource_path('USER'))
    blender_appdata_path = config_path.parent
    assert blender_appdata_path.is_dir() and blender_appdata_path.name.lower() == "blender"

    config_file_name = get_config_file_name(config_name)
    for version_dir in blender_appdata_path.iterdir():
        # Check if the folder name is in format 'number.number'
        if version_dir.is_dir() and re.match(BLENDER_VERSION_RE, version_dir.name):
            config_dir = version_dir / "config" / addon_name
            if (
                exclude_current
                and get_blender_specific_config_dir(addon_name).resolve() == config_dir.resolve()
            ):
                continue
            config_path = config_dir / config_file_name
            if os.path.isfile(config_path):
                yield (version_dir.name, config_path)


class Savable:
    """Base class for objects that can be saved and loaded from a config file.

    This class provides a simple interface for saving and loading it's state to a disk.
    In case of nested serialized classes, only the top-level class should inherit from this class.

    Variables/methods/properties that must be implemented by the class inheriting from this:
    - `addon_name`: Name of the addon this config belongs to.
    - `config_name`: Name of the config file generated by this class without the extension.
    - `save_version`: Version of the saved file format.
    - `_serialize`: Method that converts the object to a json-compatible dictionary.
    - `_deserialize`: Method that converts a json-compatible dictionary to the object state.

    For saving and loading `bpy.types.PropertyGroup` objects, use this in combination
    with `serializable_class` decorator and `Serialize()` wrapper. `serializable_class` will
    automatically implement `_serialize` and `_deserialize` methods for you.

    Variables/methods/properties that you might want to override:
    - `get_default_dir`: Directory for saving and loading the config file.
    - `auto_save`: Whether to automatically save the config on property update.
    - `auto_save_debounce`: Debounce time for auto-saving in seconds.
    - `force_pretty_print`: Whether to always pretty print the config file when saving (mainly for debugging).
    - `on_serialized_property_update`: Callback that is called every time a serialized property is
                                       updated. If overridden, you must call the base class method
                                       for the autosaving to work correctly.
    - `strict_mode`: Whether to use strict mode for deserialization. If `True`, any properties
                     missing in the loaded config will raise an error. If `False`, missing
                     properties will be ignored and left unchanged.
    - `migrate_config_data`: Method to migrate loaded config data from an older version to the
                             current version. You have to override this method if changes to the
                             config would break the loading (e.g., renaming properties, changing types, etc.).

    Example:
    ```
        @serializable_class
        class MyClass(bpy.types.PropertyGroup, Savable):

            addon_name: str = "my_addon"
            save_version: int = 1

            @property
            def config_name(self) -> str:
                return "my_config"

            my_int_property: Serialize(
                bpy.props.IntProperty(name="My Int")
            )
    ```
    """

    addon_name: str = NotImplemented  # Name of the addon this config belongs to
    save_version: int = NotImplemented  # Version of the saved file format
    auto_save_debounce: float = 0.5  # Debounce time for auto-saving in seconds
    strict_mode: bool = True  # Whether to use strict mode for deserialization
    force_pretty_print: bool = False  # Whether to always pretty print the config file

    @property
    def config_name(self) -> str:
        """Name of the config file generated by this class without the extension."""
        raise NotImplementedError("The class must implement a 'config_name' property. ")

    @property
    def auto_save(self) -> bool:
        """Whether to automatically save the config on property update."""
        return False

    @property
    def qualified_name(self) -> str:
        """Full name including addon name and config name."""
        return f"{type(self).addon_name}.{self.config_name}"

    @classmethod
    def get_default_dir(cls) -> pathlib.Path:
        """Directory for saving and loading the config file.

        This location will be used by `save`, `load`, and `file_exists` methods.
        If not overridden, it will use the Blender specific config directory.
        """
        return get_blender_specific_config_dir(cls.addon_name)

    def _get_config_path(self, create_dir: bool = False) -> pathlib.Path:
        directory = type(self).get_default_dir()
        if create_dir and not directory.exists():
            directory.mkdir(parents=True)
        return directory / get_config_file_name(self.config_name)

    def save_file_exists(self) -> bool:
        """Check if the config file exists in the predefined config directory."""
        return self._get_config_path().is_file()

    def save_custom(self, path: pathlib.Path, pretty_print: bool = False) -> None:
        """Save the current state of the object to a config file at the given path.

        This method will ignore all path related properties of the class
        and save the config to the given path instead.
        """
        if not hasattr(self, "_serialize"):
            raise AttributeError(
                "The class must implement a '_serialize' method. "
                "Did you forget to use the `serializable_class` decorator?"
            )

        data = self._serialize()  # type: ignore
        versioned_data = {
            "version": type(self).save_version,
            "data": data,
        }
        save_config(
            path, versioned_data, pretty_print=pretty_print or type(self).force_pretty_print
        )

    def save(self, pretty_print: bool = False) -> None:
        """Save the current state of the object to a predefined config file."""
        self.save_custom(self._get_config_path(create_dir=True), pretty_print=pretty_print)

    def load_custom(self, path: pathlib.Path, ignore_version: bool = False) -> None:
        """Load data from the given path and set the state of this object.

        This method will ignore all path related properties of the class
        and load the config from the given path instead.
        """
        if not path.is_file():
            raise FileNotFoundError(f"Config file at '{path}' for '{self.config_name}' not found")
        if not hasattr(self, "_deserialize"):
            raise AttributeError(
                "The class must have a '_deserialize' method."
                "Did you forget to use the `serializable_class` decorator?"
            )

        # load and deserialize the data into a dictionary
        versioned_data = load_config(path)
        if not isinstance(versioned_data, dict):
            raise errors.InvalidConfigError(
                type(self),
                f"Invalid config format. Expected dict, got {type(versioned_data)}",
            )

        # check that data field exists and is a dictionary
        data = versioned_data.get("data", None)
        if data is None:
            raise errors.InvalidConfigError(type(self), "Data not found in the loaded config")
        if not isinstance(data, dict):
            raise errors.InvalidConfigError(
                type(self),
                f"Invalid data format. Expected dict, got {type(data)}",
            )

        # check version of the loaded data
        loaded_version = versioned_data.get("version", None)
        if loaded_version is None:
            raise errors.InvalidConfigError(type(self), "Version not found in the loaded config")
        if not isinstance(loaded_version, int):
            raise errors.InvalidConfigError(
                type(self),
                "Invalid version format. Expected int, "
                f"got {type(loaded_version)} ({loaded_version})",
            )
        # migrate data to the current version if needed
        migrated = False
        if loaded_version < type(self).save_version:
            self.migrate_config_data(versioned_data, type(self).save_version)
            migrated = True
            loaded_version = versioned_data.get("version", None)
            assert (
                loaded_version is not None
            ), "migrate_config_data must set the version to the target version"
        # now the versions must match (or we are in ignore_version mode)
        if not ignore_version and loaded_version != type(self).save_version:
            raise errors.UnsupportedVersionError(
                type(self),
                type(self).save_version,
                loaded_version,
            )

        # deserializing the data will trigger auto-save by default
        # we auto-save only when migrating, otherwise we would store the same data
        autosave_override[self] = not migrated
        try:
            self._deserialize(data, type(self).strict_mode)  # type: ignore
        finally:
            autosave_override[self] = False

    def load(self, ignore_version: bool = False) -> None:
        """Load state of this object from a predefined config file."""
        self.load_custom(self._get_config_path(), ignore_version=ignore_version)

    def _auto_save(self) -> None:
        logger.info(f"Auto-saving '{self.qualified_name}'")
        self.save()
        logger.info(f"Auto-saved '{self.qualified_name}'")

    def on_serialized_property_update(self, context: bpy.types.Context, property_name: str) -> None:
        """Callback that is called every time a serialized property is updated.

        If the `auto_save` property is set to `True`, this method will automatically
        save the config file after a debounce time defined by `auto_save_debounce`.
        """
        if self.auto_save and not autosave_override.get(self, False):
            # Unfortunately, `bpy.app.timers.is_registered(self._auto_save)` won't work here,
            # we have to store the callback somewhere.
            autosave_func = autosave_timer_callbacks.get(self, None)
            if autosave_func is None:
                autosave_func = self._auto_save
                autosave_timer_callbacks[self] = autosave_func

            if bpy.app.timers.is_registered(autosave_func):  # type: ignore
                bpy.app.timers.unregister(autosave_func)  # type: ignore
            bpy.app.timers.register(
                autosave_func, first_interval=self.auto_save_debounce, persistent=True  # type: ignore
            )

    def migrate_config_data(self, versioned_data: dict, to_version: int) -> None:
        """Migrate loaded config data from an older version to the current version.

        This method is called during loading when the loaded config version is
        lower than the current `save_version`. The default implementation doesn't change
        the data and just updates the version number.
        """
        versioned_data["version"] = to_version


# These dictionaries are used to store values for `Savable` instances.
# Ideally, you could use, e.g., `self.autosave_timer_callback` inside the `Savable`,
# but `Savable` can be used on `AddonPreferences` which does not support
# attributes on `self`. To overcome this, we can use `autosave_timer_callbacks[self]`.
autosave_timer_callbacks: dict[Savable, collections.abc.Callable[[], None]] = {}
autosave_override: dict[Savable, bool] = {}
