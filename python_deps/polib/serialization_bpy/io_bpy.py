# copyright (c) 2018- polygoniq xyz s.r.o.

import bpy
import os
import json
import re
import typing
import pathlib
import sys
import logging
from . import errors

logger = logging.getLogger(f"polygoniq.{__name__}")

BLENDER_VERSION_RE = re.compile(r"^(\d+)\.(\d+)$")

CONFIG_EXT = ".confiq"


def get_global_config_dir(addon_name: str, create: bool = False) -> pathlib.Path:
    """Get the global polygoniq config directory for the addon."""
    if sys.platform.startswith("win"):
        directory = pathlib.Path.home() / "AppData" / "Local" / "polygoniq"
    elif sys.platform.startswith("linux"):
        xdg_config_home = os.environ.get("XDG_CONFIG_HOME", None)
        if xdg_config_home is not None:
            directory = pathlib.Path(xdg_config_home) / "polygoniq"
        else:
            directory = pathlib.Path.home() / ".config" / "polygoniq"
    elif sys.platform.startswith("darwin"):
        directory = pathlib.Path.home() / "Library" / "Application Support" / "polygoniq"
    else:
        raise NotImplementedError(f"Platform {sys.platform} not supported")

    directory = directory / addon_name
    if create and not directory.exists():
        directory.mkdir(parents=True)
    return directory


def get_blender_specific_config_dir(addon_name: str, create: bool = False) -> pathlib.Path:
    """Get the blender-specific config directory for the addon."""
    str_path = bpy.utils.user_resource('CONFIG', path=addon_name, create=create)
    return pathlib.Path(str_path)


def get_config_file_name(config_name: str) -> str:
    return f"{config_name}{CONFIG_EXT}"


def save_config(path: pathlib.Path, data: typing.Dict, pretty_print: bool = False) -> None:
    with path.open("w", encoding="utf-8") as f:
        json.dump(data, f, indent=4 if pretty_print else None)


def load_config(path: pathlib.Path) -> typing.Dict:
    with path.open("r", encoding="utf-8") as f:
        return json.load(f)


def list_versions_with_config(
    addon_name: str, config_name: str, exclude_current: bool = False
) -> typing.Iterator[typing.Tuple[str, pathlib.Path]]:
    """Search for the config file in 'config' folder of other Blender versions.

    Returns an iterator of all Blender versions where the config file was found
    in the format `(version, config_file_path)`. This will search only in user/system
    installations of Blender (we can't search portable versions or custom paths).
    """
    # By default, this will be `.../[bB]lender/"version"` on all platforms
    # We need to go up to the `blender` dir and check all versions
    config_path = pathlib.Path(bpy.utils.resource_path('USER'))
    blender_appdata_path = config_path.parent
    assert blender_appdata_path.is_dir() and blender_appdata_path.name.lower() == "blender"

    config_file_name = get_config_file_name(config_name)
    for version_dir in blender_appdata_path.iterdir():
        # Check if the folder name is in format 'number.number'
        if version_dir.is_dir() and re.match(BLENDER_VERSION_RE, version_dir.name):
            config_dir = version_dir / "config" / addon_name
            if (
                exclude_current
                and get_blender_specific_config_dir(addon_name).resolve() == config_dir.resolve()
            ):
                continue
            config_path = config_dir / config_file_name
            if os.path.isfile(config_path):
                yield (version_dir.name, config_path)


class Savable:
    """Base class for objects that can be saved and loaded from a config file.

    This class provides a simple interface for saving and loading it's state to a disk.
    In case of nested serialized classes, only the top-level class should inherit from this class.

    Variables/methods/properties that must be implemented by the class inheriting from this:
    - `addon_name`: Name of the addon this config belongs to.
    - `config_name`: Name of the config file generated by this class without the extension.
    - `save_version`: Version of the saved file format.
    - `_serialize`: Method that converts the object to a json-compatible dictionary.
    - `_deserialize`: Method that converts a json-compatible dictionary to the object state.

    For saving and loading `bpy.types.PropertyGroup` objects, use this in combination
    with `serializable_class` decorator and `Serialize()` wrapper.

    Variables/methods/properties that you might want to override:
    - `get_default_dir`: Directory for saving and loading the config file.
    - `auto_save`: Whether to automatically save the config on property update.
    - `auto_save_debounce`: Debounce time for auto-saving in seconds.
    - `on_serialized_property_update`: Callback that is called every time a serialized property is
                                       updated. If overridden, you must call the base class method
                                       for the autosaving to work correctly.

    Example:
    ```
        @serializable_class
        class MyClass(bpy.types.PropertyGroup, Savable):

            addon_name: str = "my_addon"
            save_version: int = 1

            @property
            def config_name(self) -> str:
                return "my_config"

            my_int_property: Serialize(
                bpy.props.IntProperty(name="My Int")
            )
    ```
    """

    addon_name: str = NotImplemented  # Name of the addon this config belongs to
    save_version: int = NotImplemented  # Version of the saved file format
    auto_save_debounce: float = 0.5  # Debounce time for auto-saving in seconds

    @property
    def config_name(self) -> str:
        """Name of the config file generated by this class without the extension."""
        raise NotImplementedError("The class must implement a 'config_name' property. ")

    @property
    def auto_save(self) -> bool:
        """Whether to automatically save the config on property update."""
        return False

    @classmethod
    def get_default_dir(cls) -> pathlib.Path:
        """Directory for saving and loading the config file.

        This location will be used by `save`, `load`, and `file_exists` methods.
        If not overridden, it will use the Blender specific config directory.
        """
        return get_blender_specific_config_dir(cls.addon_name)

    def _get_config_path(self, create_dir: bool = False) -> pathlib.Path:
        directory = type(self).get_default_dir()
        if create_dir and not directory.exists():
            directory.mkdir(parents=True)
        return directory / get_config_file_name(self.config_name)

    def save_file_exists(self) -> bool:
        """Check if the config file exists in the predefined config directory."""
        return self._get_config_path().is_file()

    def save_custom(self, path: pathlib.Path, pretty_print: bool = False) -> None:
        """Save the current state of the object to a config file at the given path.

        This method will ignore all path related properties of the class
        and save the config to the given path instead.
        """
        if not hasattr(self, "_serialize"):
            raise AttributeError(
                "The class must implement a '_serialize' method. "
                "Did you forget to use the `serializable_class` decorator?"
            )

        data = self._serialize()  # type: ignore
        versioned_data = {
            "version": type(self).save_version,
            "data": data,
        }
        save_config(path, versioned_data, pretty_print=pretty_print)

    def save(self, pretty_print: bool = False) -> None:
        """Save the current state of the object to a predefined config file."""
        self.save_custom(self._get_config_path(create_dir=True), pretty_print=pretty_print)

    def load_custom(self, path: pathlib.Path) -> None:
        """Save the current state of the object to a config file at the given path.

        This method will ignore all path related properties of the class
        and load the config from the given path instead.
        """
        if not path.is_file():
            raise FileNotFoundError(f"Config file at '{path}' for '{self.config_name}' not found")
        if not hasattr(self, "_deserialize"):
            raise AttributeError(
                "The class must have a '_deserialize' method."
                "Did you forget to use the `serializable_class` decorator?"
            )

        # load and deserialize the data into a dictionary
        versioned_data = load_config(path)
        if "version" not in versioned_data:
            raise errors.InvalidConfigError("Version not found in the config")
        loaded_version = versioned_data["version"]
        if not isinstance(loaded_version, int):
            raise errors.InvalidConfigError(
                f"Invalid version format. Expected int, got {type(loaded_version)}"
            )
        if loaded_version > type(self).save_version:
            raise errors.UnsupportedVersionError(
                f"Version of the loaded config ({loaded_version}) is higher than the currently "
                f"supported version ({type(self).save_version})"
            )

        if "data" not in versioned_data:
            raise errors.InvalidConfigError("Data not found in the config")
        if not isinstance(versioned_data["data"], dict):
            raise errors.InvalidConfigError("Data must be a dictionary")

        # override auto-save so the loading does not trigger it
        autosave_override[self] = True
        try:
            self._deserialize(versioned_data["data"])  # type: ignore
        finally:
            autosave_override[self] = False

    def load(self) -> None:
        """Load state of this object from a predefined config file."""
        self.load_custom(self._get_config_path())

    def _auto_save(self) -> None:
        logger.info(f"Auto-saving '{type(self).addon_name}.{self.config_name}'")
        self.save()
        logger.info(f"Auto-saved '{type(self).addon_name}.{self.config_name}'")

    def on_serialized_property_update(self, context: bpy.types.Context, property_name: str) -> None:
        """Callback that is called every time a serialized property is updated.

        If the `auto_save` property is set to `True`, this method will automatically
        save the config file after a debounce time defined by `auto_save_debounce`.
        """
        if self.auto_save and not autosave_override.get(self, False):
            # Unfortunately, `bpy.app.timers.is_registered(self._auto_save)` won't work here,
            # we have to store the callback somewhere.
            autosave_func = autosave_timer_callbacks.get(self, None)
            if autosave_func is None:
                autosave_func = self._auto_save
                autosave_timer_callbacks[self] = autosave_func

            if bpy.app.timers.is_registered(autosave_func):  # type: ignore
                bpy.app.timers.unregister(autosave_func)  # type: ignore
            bpy.app.timers.register(
                autosave_func, first_interval=self.auto_save_debounce, persistent=True  # type: ignore
            )


# These dictionaries are used to store values for `Savable` instances.
# Ideally, you could use, e.g., `self.autosave_timer_callback` inside the `Savable`,
# but `Savable` can be used on `AddonPreferences` which does not support
# attributes on `self`. To overcome this, we can use `autosave_timer_callbacks[self]`.
autosave_timer_callbacks: typing.Dict[Savable, typing.Callable[[], None]] = {}
autosave_override: typing.Dict[Savable, bool] = {}
